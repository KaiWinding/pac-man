<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Boom</title>
  <style type="text/css">
    #game-screen{
      border: 1px solid black;
    }

    .game-wrap{
    	position: relative;
    }

    #game-background{
    	position: absolute;
    	z-index: 100;
    	top: 0;
    	left: 0;
    }
  </style>
</head>

<body>
	<div class = "game-wrap">
	  <canvas id = "game-background" width = "800px" height = "500px"></canvas>
  	<canvas id = "game-screen" width = "800px" height = "500px"></canvas>

  </div>
  <script>
    class Wall {

      constructor(x = 0, y = 0){
        this.img = new Image()
        this.img.src = 'brick.png'
        this.positionX = x
        this.positionY = y
        this.width = 25
        this.height = 25
      }
    }

    //怪物类，吃豆人中的怪物
    class Monster {

      constructor(x = 11 * 25, y = 9 * 25){
        this.img = new Image()
        this.img.src = 'qq.png'
        this.positionX = x
        this.positionY = y
        this.width = 20 
        this.height = 23
        this.speech = 5
        this.direction = {
          'top': false,
          'bottom': false,
          'left': false,
          'right': true
        }
      }

      //怪兽的每一帧的运动方法，目前的设定要遵守的逻辑是：1.怪兽不会180度转向；2.怪兽不能撞墙；3.当怪兽遇到多个可运动方向时，随机选择一个方向移动；4.怪兽只有四个移动方向，分别是上下左右；
      move(map){

        //进行下一帧的运动判定时先判定逻辑1，即怪兽不能进行180转向，在这里将怪兽上一帧运动方向的反方向设为false，即怪兽这一帧不能向该方向运动
        if (this.direction.top) {
          this.direction.left = true
          this.direction.right = true
        } else if (this.direction.bottom) {
          this.direction.left = true 
          this.direction.right = true 
        } else if (this.direction.right) {
          this.direction.top = true 
          this.direction.bottom = true  
        } else if (this.direction.left) {
          this.direction.top = true 
          this.direction.bottom = true 
        }

        //这一段的作用是判定逻辑2，使用一个数组moveDireciton来存储怪兽下一帧可运行的方向，这里的判定方法是在各个方向上加上速度获得怪兽下一帧往这一方向运动的位置，将位置参数与map数组即地图参数比较，若该位置有墙壁即说明不可向该方向运动
        var moveDirection = []
        for (let key in this.direction) {
          if (this.direction[key]) {
            switch(key) {
              case 'top': if (map[this.positionX][this.positionY - this.speech] && map[this.positionX + this.width][this.positionY - this.speech]){}else{
                this.direction[key] = false
              }; break;
              case 'bottom': if (map[this.positionX][this.positionY + this.height + this.speech] && map[this.positionX + this.width][this.positionY + this.height + this.speech]){}else{
                this.direction[key] = false
              }; break;
              case 'right': if (map[this.positionX + this.width + this.speech][this.positionY] && map[this.positionX + this.width + this.speech][this.positionY + this.height]){}else{
                this.direction[key] = false
              }; break;
              case 'left' : if (map[this.positionX - this.speech][this.positionY] && map[this.positionX - this.speech][this.positionY + this.height]){}else{
                this.direction[key] = false
              }; break;
            }
          }
          if (this.direction[key]) {
            moveDirection.push(key)
          }
        }

        //将剩下可运动的方向进行一个随机选择，获得下一帧怪兽运动的方向
        if (moveDirection.length > 1) {
          for (let i = 0; i < moveDirection.length; i++){
            this.direction[moveDirection[i]] = false
          }
          var randomDirection = Math.floor(Math.random() * moveDirection.length + 0)
          this.direction[moveDirection[randomDirection]] = true
        } else {
        	var randomDirection = 0
        }


        //根据刚刚获得的运动方向和怪兽的速度计算出怪兽下一帧的位置
        switch(moveDirection[randomDirection]){
          case 'top': this.positionY = this.positionY - this.speech; break;
          case 'bottom': this.positionY = this.positionY + this.speech; break;
          case 'left': this.positionX = this.positionX - this.speech; break;
          case 'right': this.positionX = this.positionX + this.speech; break;
        }


      }

    }

    class PacMan {


      constructor(x = 27, y = 25){
        this.img = new Image()
        this.img.src = 'ball.png'
        this.positionX = x
        this.positionY = y
        this.width = 15 
        this.height = 15
        this.speech = 5
        this.direction = {
          'top': false,
          'bottom': false,
          'left': false,
          'right': true
        }
      }

      move(map, control){
        var nowdirection = ''

        for (let key in this.direction) {
          if (this.direction[key]) {
            nowdirection = key
          }
        }

        this.direction = {
          'top': true,
          'bottom': true,
          'left': true,
          'right': true
        }

        //这一段的作用是判定逻辑2，使用一个数组moveDireciton来存储怪兽下一帧可运行的方向，这里的判定方法是在各个方向上加上速度获得怪兽下一帧往这一方向运动的位置，将位置参数与map数组即地图参数比较，若该位置有墙壁即说明不可向该方向运动
        var moveDirection = {}
        for (let key in this.direction) {
          if (this.direction[key]) {
            switch(key) {
              case 'top': if (map[this.positionX][this.positionY - this.speech] && map[this.positionX + this.width][this.positionY - this.speech]){}else{
                this.direction[key] = false
              }; break;
              case 'bottom': if (map[this.positionX][this.positionY + this.height + this.speech] && map[this.positionX + this.width][this.positionY + this.height + this.speech]){}else{
                this.direction[key] = false
              }; break;
              case 'right': if (map[this.positionX + this.width + this.speech][this.positionY] && map[this.positionX + this.width + this.speech][this.positionY + this.height]){}else{
                this.direction[key] = false
              }; break;
              case 'left' : if (map[this.positionX - this.speech][this.positionY] && map[this.positionX - this.speech][this.positionY + this.height]){}else{
                this.direction[key] = false
              }; break;
            }
          }
          if (this.direction[key]) {
            //moveDirection.push(key)
          }
        }

        if (this.direction[control]) {
          nowdirection = control

        //根据刚刚获得的运动方向和怪兽的速度计算出怪兽下一帧的位置
        switch(nowdirection){
          case 'top': this.positionY = this.positionY - this.speech; this.direction = {
          'top': true,
          'bottom': false,
          'left': false,
          'right': false
        }; break;
          case 'bottom': this.positionY = this.positionY + this.speech; this.direction = {
          'top': false,
          'bottom': true,
          'left': false,
          'right': false
        }; break;
          case 'left': this.positionX = this.positionX - this.speech; this.direction = {
          'top': false,
          'bottom': false,
          'left': true,
          'right': false
        }; break;
          case 'right': this.positionX = this.positionX + this.speech; this.direction = {
          'top': false,
          'bottom': false,
          'left': false,
          'right': true
        }; break;
        }

      } else {
        this.direction = {
          'top': false,
          'bottom': false,
          'left': false,
          'right': false
        }
        this.direction[nowdirection] = true
      }


      }
    }

    //生成所有的墙单位，暂时没有设置好地图，用这个随便生成一个
    function createWallLish() {
      var wallList = []

      for (let i = 0; i < 32; i++){
        let newWall = new Wall(i * 25) 
        wallList.push(newWall)
      }
      for (let i = 0; i < 32; i++){
        let newWall = new Wall(i * 25, 475)
        wallList.push(newWall)
      }
  
      for (let i = 1; i < 19; i++){
        let newWall = new Wall(0, i*25)
        wallList.push(newWall)
      }

      for (let i = 1; i < 19; i++){
      	let newWall = new Wall(775 ,i*25)
      	wallList.push(newWall)
      }

      for (let i = 1; i < 19; i++){
        let newWall = new Wall(21 * 25, i*25)
        wallList.push(newWall)
      }

      for (let i = 1; i < 21; i++){
        let newWall = new Wall(i * 25, 18 * 25)
        wallList.push(newWall)
      }

      var diyWall = [ 
        [4,1], [8,1], [14,1],
        [2,2], [6,2], [8,2], [14,2], [16,2], [18,2], [19,2],
        [2,3], [4,3], [5,3], [6,3], [8,3], [9,3], [10,3], [11,3], [12,3], [13,3], [14,3], [16,3], [18,3], [19,3],
        [2,4],
        [2,5], [3,5], [4,5], [6,5], [8,5], [9,5], [10,5], [12,5], [13,5], [14,5], [15,5], [16,5], [18,5], [19,5],
        [2,6], [6,6], [14,6], [18,6], [19,6],
        [2,7], [4,7], [6,7], [8,7], [10,7], [11,7], [12,7], [16,7], [18,7], [19,7],
        [4,8], [8,8], [10,8], [11,8], [12,8], [14,8], [15,8], [16,8],
        [2,9], [3,9], [4,9], [6,9], [7,9], [8,9], [10,9], [16,9], [18,9], [19,9], [20,9],
        [4,10], [8,10], [10,10], [11,10], [12,10], [14,10], [16,10],
        [2,11], [4,11], [6,11], [8,11], [10,11], [11,11], [12,11], [14,11], [16,11], [18,11], [19,11],
        [2,12], [6,12], [14,12], [18,12], [19,12],
        [2,13], [3,13], [4,13], [6,13], [8,13], [9,13], [10,13],
        [12,13], [13,13], [14,13], [15,13], [16,13], [18,13], [19,13],
        [2,14],
        [2,15], [4,15], [5,15], [6,15], [8,15], [9,15], [10,15], [11,15], [12,15], [13,15], [14,15], [16,15], [18,15], [19,15],
        [2,16], [6,16], [8,16], [14,16], [16,16], [18,16], [19,16],
        [4,17], [8,17], [14,17]
        ]

      for (let i = 0; i < diyWall.length; i++) {
      	let newWall = new Wall(diyWall[i][0] * 25, diyWall[i][1] * 25)
        wallList.push(newWall)
      }
      return wallList
    }

    //创造一个二维数组描述整个canvas的所有像素点，初始值设为true即该点无任何对象
    function createMap(wallList){

      var map = new Array
      for (let i = 0; i < 800; i++){
        map[i] = new Array
        for (let j = 0; j < 500; j++){
          map[i][j] = true
        }
      }

      //遍历所有的墙对象，在map二维数组中将每个墙对象的占据的像素点赋值为false，即该点存在对象必须考虑可否通过的问题
      for (let i = 0; i < wallList.length; i++){
        for (let j = wallList[i].positionX; j < (wallList[i].positionX + wallList[i].width ); j++){

          for (let k = wallList[i].positionY; k < (wallList[i].positionY + wallList[i].height ); k++){

            map[j][k] = false 
          } 
        }
      }

      return map
    }

    class Game{

      constructor(){
        this.keyBoard = {}
        this.action = {}
        var that = this
        window.addEventListener('keydown',function(event){
          that.keyBoard[event.key] = true
        })
        window.addEventListener('keyup',function(event){
          that.keyBoard[event.key] = false
        })
      }

      //注册按键事件
      registerAction(keyword,callback){
        this.action[keyword]=callback
      }

      refresh(pacMan,wallList,map,screen,background){
        var monster = new Monster
        var monsterList = [
        //  new Monster(27, 25), new Monster(11 * 25, 6 * 25), new Monster(13 * 25, 9 * 25)]
          new Monster, new Monster, new Monster, new Monster, new Monster]
        const ctx = screen.getContext('2d')
        const backgroundCtx = background.getContext('2d')
        var time = 0
        var closeDoor = false
        var that = this

        setTimeout(function(){
  	      for (let i = 0; i < wallList.length; i++){
          	backgroundCtx.drawImage(wallList[i].img,wallList[i].positionX,wallList[i].positionY,wallList[i].width,wallList[i].height)
          }        	
        },1)

        setInterval(function(){

          for (let key in that.action) {
            if (that.keyBoard[key]) {
            that.action[key]()
            }
          }



          time++
          if ((time > 50) && (!closeDoor)) {
            let door = new Wall(12 * 25, 9 * 25)
            backgroundCtx.drawImage(door.img,door.positionX,door.positionY,door.width,door.height)
            for (let j = door.positionX; j < (door.positionX + door.width ); j++){

              for (let k = door.positionY; k < (door.positionY + door.height ); k++){

                map[j][k] = false 
              } 
            }
          } 

          ctx.clearRect(0,0,screen.width,screen.height)

          ctx.drawImage(pacMan.img,pacMan.positionX,pacMan.positionY,pacMan.width,pacMan.height)


          for (let i = 0; i < monsterList.length; i++) {
          monsterList[i].move(map)
          ctx.drawImage(monsterList[i].img,monsterList[i].positionX,monsterList[i].positionY,monsterList[i].width,monsterList[i].height)
        }
        },1000/40)
      }
    }

    function __main(){
      const screen = document.getElementById('game-screen')

      const background = document.getElementById('game-background')

       pacMan = new PacMan
      var game = new Game
      var wallList = createWallLish()
       map = createMap(wallList) 

      game.registerAction('a', function(){
        pacMan.move(map, 'left')
      })
      game.registerAction('w', function(){
        pacMan.move(map, 'top')
      })
      game.registerAction('s', function(){
        pacMan.move(map, 'bottom')
      })
      game.registerAction('d', function(){
        pacMan.move(map, 'right')
      })

      game.refresh(pacMan,wallList, map, screen,background)
    }

    __main()
  </script>
</body>
</html>